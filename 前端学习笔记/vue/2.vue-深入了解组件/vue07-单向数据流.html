<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<div id="app">
			<p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
			<p>额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<b>不应该</b>在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。 </p>
			<test1 initial-counter=5></test1>

			<test2 size=" IJNI ujoijoYIJUj"></test2>
			<!-- 注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身将会影响到父组件的状态。 -->
		</div>
		<!-- ===========================================内容脚本分界线=========================================== -->
		<script src="../statics/vue-2.7.14.js"></script>
		<script type="text/javascript">
			//这里有两种常见的试图变更一个 prop 的情形：

			/* 
				这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。
				在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值 */
			
			Vue.component('test1',{
				props:['initialCounter'],
				data(){return{counter:this.initialCounter}},
				template:'<h3>{{counter}}</h3>'
			})
			
			/* 这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性： */
			Vue.component('test2',{
				props: ['size'],
				computed: {
				  normalizedSize() {
				    return this.size.trim().toLowerCase()
				  }
				},
				template:'<h3>{{normalizedSize}}</h3>'
			})
			
			new Vue({
				el:'#app',
				data:{
					
				}
			})
			
		</script>
	</body>
</html>