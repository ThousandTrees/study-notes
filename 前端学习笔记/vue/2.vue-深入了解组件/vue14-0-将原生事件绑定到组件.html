<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<div id="app">
			
			<h1>将原生事件绑定到组件</h1> 
			<!-- 在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 v-on 的 .native 修饰符： -->
			<base-input v-on:focus.native="onFocus"></base-input>
			
			<!-- 这时，父级的 .native 监听器将静默失败。它不会产生任何报错，但是 onFocus 处理函数不会如你预期地被调用。 -->
			<base-label-input v-on:focus.native="onFocus"></base-label-input>
			
			<!-- 
				为了解决这个问题，Vue 提供了一个 $listeners property，它是一个对象，里面包含了作用在这个组件上的所有监听器。例如：
				
				$listeners:{
					focus: function (event) { /* ... */ }
					input: function (value) { /* ... */ },
				}
			 -->
		</div>
		<!-- ===========================================内容脚本分界线=========================================== -->
		<script src="../statics/vue-2.7.14.js"></script>
		<script type="text/javascript">
			Vue.component('base-input',{
				props:['value'],
				template:`<input>`
			})
			
			/*
				在有的时候这是很有用的，不过在你尝试监听一个类似 <input> 的非常特定的元素时，这并不是个好主意。比如上述 <base-input> 组件可能做了如下重构，所以根元素实际上是一个 <label> 元素：
			 */
			
			Vue.component('base-label-input',{
				props:['value','label'],
				template:`
				<label>
				  {{ label }}
				  <input
				    v-bind="$attrs"
				    v-bind:value="value"
				    v-on:input="$emit('input', $event.target.value)"
				  >
				</label>
				`
			})
			
			new Vue({
				el:'#app',
				data:{
					
				},
				methods:{
					onFocus(){console.log('focused')}
				}
			})
		</script>
	</body>
</html>